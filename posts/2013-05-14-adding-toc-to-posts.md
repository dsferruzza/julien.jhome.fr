---
title: Adding TOC to posts using contexts and versions
date: 2013-05-14
author: Julien Tanguy
description: Adding a table of contents to post contexts
tags: haskell, meta
---
I recently added a table of contents to my posts.
This is not really difficult, and I thought I might do a little tutorial on it.

For reference, we will start from this compilation rule for blog posts:

~~~{.haskell}
match "posts/*" $ do
    route   $ setExtension ".html"
    compile $ pandocCompiler
        >>= loadAndApplyTemplate "templates/post.html" (tagsCtx tags)
        >>= loadAndApplyTemplate "templates/default.html" defaultContext
        >>= relativizeUrls
~~~

# Pandoc only

The first way of adding a table of contents to posts is to edit the pandoc `WriterOptions` in the compilation rules of posts:

~~~{.haskell}
match "posts/*" $ do
    route   $ setExtension ".html"
    compile $ pandocCompilerWith defaultHakyllReaderOptions
                                 defaultHakyllWriterOptions {
                                    writerTableOfContents = True
                                  , writerTemplate = unlines
                                                   [ "Table of contents"
                                                   , "$toc$"
                                                   , "$body$"
                                                   ]
                                  , writerStandalone = True
                                  }
~~~

However, there are two caveats to this method:

- All titles are converted to links to themselves[^1], and
- You are limited to the placement of the TOC.

The first issue may not be a problem for everyone, but I find that a link should point by definition to another location.

The latter is more of a problem. It means that you have to put some template content inside the pandoc writer option.

Let us illustrate that on the skeleton I have for this blog:

~~~
article
    +- header (post title)
    +- aside (nav)
    +- section (article body)
~~~

If we want the right tags, we would have to write the `aside` and `section` tags
_inside_ the pandoc template, which is _compiled_ and thus more rigid.

# Putting the TOC into a context

What we need to do is to compile the table of contents _separately_, so we can put it 
back into the posts' contexts.
For this trick we will use different `version`s of the posts.[^2]

The `toc` version will contain only the table of contents, while the unversioned page
will have our compiled html.

## Generating the toc

The toc is generated by the following rule:

~~~{.haskell}
match "posts/*" $ version "toc" $
   compile $ pandocCompilerWith defaultHakyllReaderOptions
                                defaultHakyllWriterOptions {
                                    writerTableOfContents = True
                                  , writerTemplate = "$toc$"
                                  , writerStandalone = True
                                  }
~~~

Notice that the `$body$` key does not appear in the pandoc template.
We write only the table of contents.

## Putting the toc back into the post

We will put the toc back into the post inside the post context:

~~~{.haskell}
tagsCtx :: Tags -> Context String
tagsCtx tags = mconcat
    [ tagsField "prettytags" tags
    , field "toc" $ \item ->
            loadBody ((itemIdentifier item) { identifierVersion = Just "toc"})
    , defaultContext
    ]
~~~

Because the toc is only a different version of the same item,
we can get the body by loading the body of the very item we are compiling
--- the `\item` argument to our lambda function --- and adding the toc version.

And here we are ! We have a nice context for blog posts which will contain a `toc`
field containing the ... table of contents of the said post.

We just need to tweak the post template a little bit:

~~~{.html}
<article>
    <header>
        <!-- The usual post header: title, author, tags, etc. -->
    </header>
    <aside role="nav">
    $toc$
    </aside>
    <section>
    $body$
    </section>
</article>
~~~

And we are done! We just need to compile our site, and we can adapt the templates
_without recompiling_ our blog rules.[^3]

[^1]: For instance, a `#My title` would be translated as `<h1 id="my-title"><a href="#my-title">My title</a></h1>`.

[^2]: You can find more on versions [on the hakyll website](http://jaspervdj.be/hakyll/tutorials/06-versions.html)

[^3]: If you did not have any particular versions of your posts, you might have to change
all `"posts/*"` patterns into `("posts/*" .&&. hasNoVersion)`.
